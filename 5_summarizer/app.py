import streamlit as st
import io
from streamlit_mic_recorder import mic_recorder

# Assumindo que essas importa√ß√µes funcionam corretamente
from src.pipelines.pdf_pipeline import process_pdf_file
from src.pipelines.rag_pipeline import RAG
from src.pipelines.summarizer import Summarizer
from src.core.chunking import TextChunker
from src.services.transcription_service import TranscriptionService

def init_session_state():
    st.session_state.setdefault("rag_system", RAG())
    st.session_state.setdefault("summarizer", Summarizer())
    st.session_state.setdefault("transcription", TranscriptionService())
    
    st.session_state.setdefault("user_question_text", "") # Conte√∫do atual do text_input
    st.session_state.setdefault("response", "")
    st.session_state.setdefault("text_input_key_counter", 0) # Para for√ßar a atualiza√ß√£o do text_input

    # Novo estado para controlar o √°udio
    st.session_state.setdefault("audio_to_process", None) # Armazena os bytes do √°udio se houver
    st.session_state.setdefault("processing_audio_step", "") # 'transcribing', 'querying_ai', ''
    # Guarda o hash do √°udio para saber se √© um √°udio novo ou o mesmo que j√° foi processado
    st.session_state.setdefault("last_processed_audio_hash", None) 

def handle_pdf_upload():
    st.header("üìÑ Upload de PDF")
    pdf_file = st.file_uploader("Envie um PDF com o conte√∫do de estudo", type=["pdf"])

    if pdf_file:
        with st.spinner("Processando PDF..."):
            try:
                chunks = process_pdf_file(pdf_file)
                st.session_state.rag_system.add_documents(chunks)
                full_text = " ".join(chunk["text"] for chunk in chunks)
                st.session_state.full_text = full_text

                st.success(f"‚úÖ PDF '{pdf_file.name}' carregado com {len(chunks)} chunks.")
            except Exception as e:
                st.error(f"‚ùå Erro ao processar PDF: {str(e)}")
                return

        with st.spinner("Gerando resumo e perguntas..."):
            summarizer = st.session_state.summarizer
            try:
                summary = summarizer.generate_summary(full_text)
                st.subheader("üìå Resumo:")
                st.write(summary)

                num_questions = st.session_state.num_questions
                questions = summarizer.generate_questions(full_text, num_questions)
                st.subheader("‚ùì Perguntas geradas:")
                for q in questions:
                    st.markdown(f"**Q:** {q['question']}  \n**A:** {q['answer']}")
            except Exception as e:
                st.error(f"‚ùå Erro ao gerar resumo e perguntas: {str(e)}")

def handle_manual_text():
    st.header("üìù Inserir texto manualmente")
    content = st.text_area("Cole ou digite o conte√∫do", height=300)

    if st.button("Processar texto"):
        if not content.strip():
            st.error("‚ö†Ô∏è Por favor, insira algum texto.")
            return

        with st.spinner("Processando texto..."):
            rag_system = st.session_state.rag_system
            summarizer = st.session_state.summarizer

            chunks = TextChunker().create_chunks(content, source="manual_input")
            rag_system.add_documents(chunks)
            st.session_state.full_text = content

            summary = summarizer.generate_summary(content)
            st.subheader("üìå Resumo:")
            st.write(summary)

            num_questions = st.session_state.num_questions
            questions = summarizer.generate_questions(content, num_questions)
            st.subheader("‚ùì Perguntas geradas:")
            for q in questions:
                st.markdown(f"**Q:** {q['question']}  \n**A:** {q['answer']}")


# Fun√ß√£o para processar a pergunta (texto ou √°udio)
def process_query_and_get_response(query_text: str):
    if not query_text.strip():
        st.toast("‚ö†Ô∏è Por favor, digite ou grave uma pergunta v√°lida.")
        st.session_state.response = ""
        st.session_state.user_question_text = ""
        return

    st.session_state.response = "" # Limpa a resposta anterior antes de consultar

    spinner_placeholder_ai = st.empty() 
    with spinner_placeholder_ai.container():
        st.info("Consultando IA...") 

    try:
        rag = st.session_state.rag_system
        response = rag.query_and_respond(query_text, n_results=1)
        st.session_state.response = response
        st.toast("‚úÖ Resposta gerada!")
    except Exception as e:
        st.error(f"‚ùå Erro ao buscar resposta: {e}")
        st.session_state.response = f"N√£o foi poss√≠vel obter uma resposta: {e}"
    finally:
        spinner_placeholder_ai.empty() # Remove o spinner da IA

# Callback para o input de texto (acionado ao digitar e pressionar Enter)
def on_text_input_submit():
    current_text = st.session_state[f"user_question_input_{st.session_state.text_input_key_counter}"].strip()
    if current_text:
        # Garante que n√£o vamos reprocessar √°udio se o texto foi digitado
        st.session_state.audio_to_process = None 
        st.session_state.processing_audio_step = ""
        st.session_state.last_processed_audio_hash = None # Limpa o hash do √°udio processado
        
        process_query_and_get_response(current_text)
        st.session_state.user_question_text = "" # Limpa o input ap√≥s processar o texto digitado
    else:
        st.toast("‚ö†Ô∏è Por favor, digite uma pergunta v√°lida.")
        st.session_state.user_question_text = ""


def handle_Youtubeing():
    st.header("üîç Perguntar sobre conte√∫do")

    col1, col2 = st.columns([8, 1])

    with col1:
        st.text_input(
            "Digite sua pergunta (pressione Enter para perguntar):",
            value=st.session_state.user_question_text,
            key=f"user_question_input_{st.session_state.text_input_key_counter}",
            on_change=on_text_input_submit
        )

    with col2:
        # mic_recorder sem callback direto, apenas retorna audio_data
        current_mic_audio_data = mic_recorder(
            start_prompt="üé§",
            stop_prompt="‚úÖ",
            key="mic_recorder"
        )
        
    # Calcular um hash simples do √°udio para verificar se √© novo
    current_audio_hash = None
    if current_mic_audio_data and current_mic_audio_data.get('bytes'):
        current_audio_hash = hash(current_mic_audio_data['bytes']) # Cria um hash dos bytes do √°udio

    # L√≥gica de processamento de √°udio:
    # Este bloco √© executado SE:
    # 1. H√° audio_data (algo foi gravado).
    # 2. N√ÉO h√° √°udio j√° agendado para processamento (audio_to_process √© None).
    # 3. O √°udio atual √© DIFERENTE do √∫ltimo √°udio que j√° foi processado (evita reprocessar o mesmo √°udio).
    if current_mic_audio_data and current_mic_audio_data.get('bytes') and \
       not st.session_state.audio_to_process and \
       current_audio_hash != st.session_state.last_processed_audio_hash:
        
        st.session_state.audio_to_process = current_mic_audio_data['bytes']
        st.session_state.processing_audio_step = "transcribing" # Sinaliza o in√≠cio da transcri√ß√£o
        st.session_state.last_processed_audio_hash = current_audio_hash # Armazena o hash do √°udio que ser√° processado
        st.session_state.text_input_key_counter += 1 # Para resetar/atualizar o input visualmente
        st.rerun() # For√ßa o rerun para iniciar o processamento do √°udio

    # Bloco para processar o √°udio (transcri√ß√£o e consulta √† IA)
    # Este bloco s√≥ roda SE houver √°udio para processar E a etapa estiver definida
    if st.session_state.audio_to_process and st.session_state.processing_audio_step:
        # Step 1: Transcribing
        if st.session_state.processing_audio_step == "transcribing":
            st.toast("üéôÔ∏è Transcrevendo √°udio...")
            st.audio(st.session_state.audio_to_process, format="audio/wav")

            spinner_placeholder_transcribe = st.empty()
            with spinner_placeholder_transcribe.container():
                st.info("Transcrevendo √°udio...") # Spinner fixo durante a transcri√ß√£o
            
            try:
                transcript = st.session_state.transcription.transcribe(io.BytesIO(st.session_state.audio_to_process))
                st.session_state.user_question_text = transcript # Atualiza o input de texto
                st.toast("‚úÖ Transcri√ß√£o conclu√≠da!")

                # Mover para a pr√≥xima etapa: consulta √† IA
                st.session_state.processing_audio_step = "querying_ai"
                st.rerun() # For√ßa rerun para exibir a transcri√ß√£o e iniciar consulta √† IA
            except Exception as e:
                st.error(f"‚ùå Erro na transcri√ß√£o: {e}")
                st.session_state.response = f"N√£o foi poss√≠vel transcrever: {e}"
                st.session_state.user_question_text = ""
                st.session_state.audio_to_process = None # Limpa o √°udio
                st.session_state.processing_audio_step = "" # Reseta a etapa
                st.session_state.last_processed_audio_hash = None # Limpa o hash em caso de erro
            finally:
                spinner_placeholder_transcribe.empty() # Garante que o spinner de transcri√ß√£o seja limpo

        # Step 2: Querying AI after transcription
        elif st.session_state.processing_audio_step == "querying_ai":
            query_text_from_audio = st.session_state.user_question_text
            
            if query_text_from_audio: # Garante que a transcri√ß√£o n√£o seja vazia
                process_query_and_get_response(query_text_from_audio)
                st.session_state.user_question_text = "" # Limpa o input ap√≥s a resposta da IA

            # Reseta os estados do √°udio para a pr√≥xima intera√ß√£o
            st.session_state.audio_to_process = None
            st.session_state.processing_audio_step = ""
            st.session_state.last_processed_audio_hash = None # Limpa o hash ap√≥s o processamento completo

            # Um √∫ltimo rerun pode ser necess√°rio para garantir que o input seja limpo e a resposta apare√ßa
            # Se a resposta n√£o estiver aparecendo, descomente a linha abaixo.
            # st.rerun() 

    # Mostrar resposta
    if st.session_state.response:
        st.subheader("‚úÖ Resposta encontrada:")
        st.write(st.session_state.response)


def main():
    st.set_page_config(page_title="Summarizer", layout="wide")

    init_session_state()

    st.title("üìö Summarizer: Aprenda com IA")
    st.write("Gere resumos, perguntas e consulte conte√∫dos com IA (texto, PDF ou voz).")

    # Sidebar
    st.sidebar.header("üî∑ Menu Principal")
    menu = st.sidebar.radio(
        "Escolha o modo de uso:",
        ["üìÑ Upload de PDF", "üìù Inserir texto manualmente", "üîç Perguntar sobre conte√∫do"]
    )

    st.sidebar.header("üîß Configura√ß√µes")
    st.session_state.num_questions = st.sidebar.slider(
        "Quantidade de perguntas/flashcards", min_value=3, max_value=7, value=5
    )

    if st.sidebar.button("üîÑ Resetar tudo"):
        st.session_state.clear()
        st.experimental_rerun()

    if menu == "üìÑ Upload de PDF":
        handle_pdf_upload()
    elif menu == "üìù Inserir texto manualmente":
        handle_manual_text()
    elif menu == "üîç Perguntar sobre conte√∫do":
        handle_Youtubeing()

    st.markdown("---")
    st.caption("Desenvolvido por XXX. Powered by LLMs & Streamlit")

if __name__ == "__main__":
    main()